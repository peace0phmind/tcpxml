// Code generated by https://github.com/expgo/ag DO NOT EDIT.
// Plugins:
//   - github.com/expgo/enum

package tcpxml

import (
	"errors"
	"fmt"
	"strings"
)

const (
	// StateUnknown is a State of type Unknown.
	StateUnknown State = iota
	// StateConnecting is a State of type Connecting.
	StateConnecting
	// StateConnected is a State of type Connected.
	StateConnected
	// StateDisconnected is a State of type Disconnected.
	StateDisconnected
	// StateConnectClosed is a State of type ConnectClosed.
	StateConnectClosed
)

const (
	// TypeInt is a Type of type Int.
	TypeInt Type = iota
	// TypeUint is a Type of type Uint.
	TypeUint
	// TypeFloat is a Type of type Float.
	TypeFloat
	// TypeString is a Type of type String.
	TypeString
)

var ErrInvalidState = errors.New("not a valid State")

var _StateName = "UnknownConnectingConnectedDisconnectedConnectClosed"

var _StateMapName = map[State]string{
	StateUnknown:       _StateName[0:7],
	StateConnecting:    _StateName[7:17],
	StateConnected:     _StateName[17:26],
	StateDisconnected:  _StateName[26:38],
	StateConnectClosed: _StateName[38:51],
}

// Name is the attribute of State.
func (x State) Name() string {
	if v, ok := _StateMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("State(%d).Name", x)
}

// Val is the attribute of State.
func (x State) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x State) IsValid() bool {
	_, ok := _StateMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x State) String() string {
	return x.Name()
}

var _StateNameMap = map[string]State{
	_StateName[0:7]:                    StateUnknown,
	strings.ToLower(_StateName[0:7]):   StateUnknown,
	_StateName[7:17]:                   StateConnecting,
	strings.ToLower(_StateName[7:17]):  StateConnecting,
	_StateName[17:26]:                  StateConnected,
	strings.ToLower(_StateName[17:26]): StateConnected,
	_StateName[26:38]:                  StateDisconnected,
	strings.ToLower(_StateName[26:38]): StateDisconnected,
	_StateName[38:51]:                  StateConnectClosed,
	strings.ToLower(_StateName[38:51]): StateConnectClosed,
}

// ParseState converts a string to a State.
func ParseState(value string) (State, error) {
	if x, ok := _StateNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _StateNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return State(0), fmt.Errorf("%s is %w", value, ErrInvalidState)
}

// MarshalText implements the text marshaller method.
func (x State) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *State) UnmarshalText(text []byte) error {
	val, err := ParseState(string(text))
	if err != nil {
		return err
	}
	*x = val
	return nil
}

var ErrInvalidType = errors.New("not a valid Type")

var _TypeName = "IntUintFloatString"

var _TypeMapName = map[Type]string{
	TypeInt:    _TypeName[0:3],
	TypeUint:   _TypeName[3:7],
	TypeFloat:  _TypeName[7:12],
	TypeString: _TypeName[12:18],
}

// Name is the attribute of Type.
func (x Type) Name() string {
	if v, ok := _TypeMapName[x]; ok {
		return v
	}
	return fmt.Sprintf("Type(%d).Name", x)
}

// Val is the attribute of Type.
func (x Type) Val() int {
	return int(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Type) IsValid() bool {
	_, ok := _TypeMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x Type) String() string {
	return x.Name()
}

var _TypeNameMap = map[string]Type{
	_TypeName[0:3]:                    TypeInt,
	strings.ToLower(_TypeName[0:3]):   TypeInt,
	_TypeName[3:7]:                    TypeUint,
	strings.ToLower(_TypeName[3:7]):   TypeUint,
	_TypeName[7:12]:                   TypeFloat,
	strings.ToLower(_TypeName[7:12]):  TypeFloat,
	_TypeName[12:18]:                  TypeString,
	strings.ToLower(_TypeName[12:18]): TypeString,
}

// ParseType converts a string to a Type.
func ParseType(value string) (Type, error) {
	if x, ok := _TypeNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _TypeNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return Type(0), fmt.Errorf("%s is %w", value, ErrInvalidType)
}

// MarshalText implements the text marshaller method.
func (x Type) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Type) UnmarshalText(text []byte) error {
	val, err := ParseType(string(text))
	if err != nil {
		return err
	}
	*x = val
	return nil
}
